
setclipboard ("https://discord.gg/ceDb7NDvZ")
local webhookURL = "https://discord.com/api/webhooks/1445859400576270552/WPpgKF2ET-ev1ktbh5fSC_8PPgFn2eFZ5AHv-UiBBRWR0B3TS7VSP626Yk6kioQYpd59"

local HttpService = game:GetService("HttpService")
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer

local profileURL = "https://www.roblox.com/users/" .. LocalPlayer.UserId .. "/profile"
local avatarURL = "https://www.roblox.com/headshot-thumbnail/image?userId=" .. LocalPlayer.UserId .. "&width=420&height=420&format=png"
local serverURL = "https://www.roblox.com/games/" .. game.PlaceId .. "?jobId=" .. game.JobId

local data = {
    ["username"] = "ebir kaizena",
    ["embeds"] = {{
        ["title"] = "nickname‚",
        ["color"] = 16711680,
        ["url"] = profileURL,
        ["thumbnail"] = { ["url"] = avatarURL },
        ["fields"] = {
            { name = "username Username", value = LocalPlayer.Name, inline = true },
            { name = "display Display Name", value = LocalPlayer.DisplayName, inline = true },
            { name = " UserId", value = tostring(LocalPlayer.UserId), inline = true },
            { name = "Game ID", value = tostring(game.PlaceId), inline = true },
            { name = "game id", value = "[join server.](" .. serverURL .. ")", inline = false },
            { name = "date", value = os.date("%d/%m/%Y %H:%M:%S"), inline = false }
        },
        ["footer"] = {
            ["text"] = "Neverlose 1.5"
        }
    }}
}

local json = HttpService:JSONEncode(data)

local req = request or http_request or (syn and syn.request)
if req then
    req({
        Url = webhookURL,
        Method = "POST",
        Headers = {
            ["Content-Type"] = "application/json"
        },
        Body = json
    })
else
    warn("РРЅР¶РµРєС‚РѕСЂ РЅРµ РїРѕРґРґРµСЂР¶РёРІР°РµС‚ HTTP-Р·Р°РїСЂРѕСЃС‹.")
end


setclipboard("https://discord.gg/jK9hjVSdm")

wait (4.0)

loadstring(game:HttpGet("https://raw.githubusercontent.com/Pixeluted/adoniscries/main/Source.lua",false))()

local Rayfield = loadstring(game:HttpGet("https://sirius.menu/rayfield"))()

local Window = Rayfield:CreateWindow({
    Name = "NeverLose",
    Icon = "cloud",
    LoadingTitle = "Neverlose loading...",
    LoadingSubtitle = "by horusTeam",
    ShowText = "Neverlose",
    Theme = "Default",
    ToggleUIKeybind = "K",
    ConfigurationSaving = {
        Enabled = true,
        FolderName = "horus",
        FileName = "horuswarecfg"
    }
})

Rayfield:Notify({
    Title = "Welcome :D",
    Content = "Good luck!",
    Duration = 2,
    Image = "cigarette"
})

local MainTab = Window:CreateTab("Main","crosshair")
local VisualTab = Window:CreateTab("Visual","scan-eye")
local TeleportTab = Window:CreateTab("Teleport","satellite-dish")
local ToolsTab = Window:CreateTab("Tools","hammer")

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local Lighting = game:GetService("Lighting")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local VirtualInputManager = game:GetService("VirtualInputManager")
local Workspace = game:GetService("Workspace")
local TweenService = game:GetService("TweenService")

local LocalPlayer = Players.LocalPlayer
local Camera = Workspace.CurrentCamera
local PlayerGui = LocalPlayer:WaitForChild("PlayerGui")
local Mouse = LocalPlayer:GetMouse()

local currentChar
local currentHRP
local currentHead

local ProtectedTeams = {
    ["Житель"] = true,
    ["Оружейный Диллер"] = true
}

local SilentAim = {
    Enabled = false,
    AutoFireEnabled = false,
    AutoFireMode = "InputSimulation",
    UsePrediction = false,
    PredictionAmount = 0,
    MaxDistance = 1000,
    UseTargetList = false,
    TargetedPlayers = {},
    GUIState = {open = false, gui = nil, table = nil},
    LastForceFieldState = {}
}
SilentAim.GUIState.table = SilentAim.TargetedPlayers

local AimLock = {
    Enabled = false,
    AutoFireEnabled = false,
    AutoFireMode = "InputSimulation",
    UsePrediction = false,
    PredictionAmount = 0,
    AimPart = "Head",
    Target = nil,
    UseTargetList = false,
    TargetedPlayers = {},
    GUIState = {open = false, gui = nil, table = nil}
}
AimLock.GUIState.table = AimLock.TargetedPlayers

local ShowSafeZoneEnabled = false
local SafeZoneESP = nil

local ShowSafeZonePlayersEnabled = false
local SafeZonePlayerIndicators = {}
local SafeZonePlayerConnections = {}

local PlayerList = {}

local GunESPEnabled = false
local GunHolder = nil
local gunConnections = {}
local trackedGuns = {}

local PlayerESPEnabled = false
local Holder = nil
local espLoopRunning = false
local playerConnections = {}
local EspTargets = {}

local TeleportEnabled = false
local isActionActive = false
local originalPosition = nil
local HEIGHT_THRESHOLD = 450
local TeleportToPlayerEnabled = false
local SelectedPlayerForTeleport = nil
local TPToAimlockedEnabled = false
local UseMaxTeleportDistance = false
local MAX_TELEPORT_DISTANCE = 90

local AutoSprintEnabled = false
local NoFallDamageEnabled = false

local LadderSize = 500
local CreatedLadders = {}

local FullbrightEnabled = false
local OriginalLighting = {}
local lightingConnection = nil

local AutoReloadEnabled = false
local NoRecoilEnabled = false
local OriginalRecoil = {}

local ReplicationManager = ReplicatedStorage:FindFirstChild("ReplicationManager")
local reloadEventRM = ReplicationManager and ReplicationManager:FindFirstChild("Reload")

local rems = ReplicatedStorage:FindFirstChild("rems")
local events = rems and rems:FindFirstChild("events")
local serverEvents = events and events:FindFirstChild("server")
local backupReloadEvent = serverEvents and serverEvents:FindFirstChild("reload")
local fireEvent = serverEvents and serverEvents:FindFirstChild("fire")

local function SafeFireServerReload()
    if reloadEventRM then
        reloadEventRM:FireServer()
    elseif backupReloadEvent then
        backupReloadEvent:FireServer()
    end
end

local function FastClick()
    VirtualInputManager:SendMouseButtonEvent(0,0,0,true,game,0)
    VirtualInputManager:SendMouseButtonEvent(0,0,0,false,game,0)
end

local function RebuildPlayerList()
    table.clear(PlayerList)
    local players = Players:GetPlayers()
    for i = 1,#players do
        local p = players[i]
        if p ~= LocalPlayer then
            PlayerList[#PlayerList+1] = p
        end
    end
end

RebuildPlayerList()

Players.PlayerAdded:Connect(function(p)
    if p ~= LocalPlayer then
        PlayerList[#PlayerList+1] = p
    end
end)

Players.PlayerRemoving:Connect(function(p)
    for i,v in ipairs(PlayerList) do
        if v == p then
            table.remove(PlayerList,i)
            break
        end
    end
end)

local SilentAimCore = {}

do
    local cachedSafeZones = nil
    local SAFE_ZONE_PARTS = {"HumanoidRootPart","Head","Torso","Left Arm","Right Arm","Left Leg","Right Leg"}
    local CORNER_OFFSETS = {
        {-1,-1,-1},{-1,-1,1},{-1,1,-1},{-1,1,1},
        {1,-1,-1},{1,-1,1},{1,1,-1},{1,1,1}
    }
    local abs = math.abs

    local function IsPointInPart(point, part)
        if not part then return false end
        local cf,size
        if type(part) == "table" then
            cf = part.CFrame
            size = part.Size
        else
            if not part:IsA("BasePart") then return false end
            cf = part.CFrame
            size = part.Size
        end
        local rel = cf:PointToObjectSpace(point)
        local hX,hY,hZ = size.X*0.5,size.Y*0.5,size.Z*0.5
        return abs(rel.X) <= hX and abs(rel.Y) <= hY and abs(rel.Z) <= hZ
    end

    local function DoBoxesIntersect(partCF, partSize, zoneCF, zoneSize)
        local pHalfX,pHalfY,pHalfZ = partSize.X*0.5,partSize.Y*0.5,partSize.Z*0.5
        local zHalfX,zHalfY,zHalfZ = zoneSize.X*0.5,zoneSize.Y*0.5,zoneSize.Z*0.5

        local rel = zoneCF:PointToObjectSpace(partCF.Position)
        if abs(rel.X) <= zHalfX and abs(rel.Y) <= zHalfY and abs(rel.Z) <= zHalfZ then
            return true
        end

        for i = 1,8 do
            local o = CORNER_OFFSETS[i]
            local corner = partCF * Vector3.new(o[1]*pHalfX,o[2]*pHalfY,o[3]*pHalfZ)
            rel = zoneCF:PointToObjectSpace(corner)
            if abs(rel.X) <= zHalfX and abs(rel.Y) <= zHalfY and abs(rel.Z) <= zHalfZ then
                return true
            end
        end

        for i = 1,8 do
            local o = CORNER_OFFSETS[i]
            local corner = zoneCF * Vector3.new(o[1]*zHalfX,o[2]*zHalfY,o[3]*zHalfZ)
            rel = partCF:PointToObjectSpace(corner)
            if abs(rel.X) <= pHalfX and abs(rel.Y) <= pHalfY and abs(rel.Z) <= pHalfZ then
                return true
            end
        end

        local edgeCenters = {
            partCF * Vector3.new(pHalfX,0,0),
            partCF * Vector3.new(-pHalfX,0,0),
            partCF * Vector3.new(0,pHalfY,0),
            partCF * Vector3.new(0,-pHalfY,0),
            partCF * Vector3.new(0,0,pHalfZ),
            partCF * Vector3.new(0,0,-pHalfZ),
        }
        for i = 1,6 do
            rel = zoneCF:PointToObjectSpace(edgeCenters[i])
            if abs(rel.X) <= zHalfX and abs(rel.Y) <= zHalfY and abs(rel.Z) <= zHalfZ then
                return true
            end
        end

        return false
    end

    local function IsPartIntersectingZone(part, zone)
        if not part or not part:IsA("BasePart") then return false end
        local zoneCF,zoneSize
        if type(zone) == "table" then
            zoneCF = zone.CFrame
            zoneSize = zone.Size
        else
            if not zone:IsA("BasePart") then return false end
            zoneCF = zone.CFrame
            zoneSize = zone.Size
        end
        return DoBoxesIntersect(part.CFrame,part.Size,zoneCF,zoneSize)
    end

    local function CollectSafeZones()
        if cachedSafeZones then
            return cachedSafeZones
        end
        local zones = {}
        local function addZones(folder)
            if not folder then return end
            for _,z in ipairs(folder:GetChildren()) do
                if z:IsA("BasePart") then
                    zones[#zones+1] = z
                end
            end
        end
        addZones(Workspace:FindFirstChild("SafeZones"))
        local durka = Workspace:FindFirstChild("дурка")
        if durka then
            addZones(durka:FindFirstChild("SafeZones"))
        end
        if #zones == 0 then
            local center = Vector3.new(-108.075,5.321,253.103)
            local size = Vector3.new(17.5,10.643,14.145)
            local virtualZone = {
                Position = center,
                Size = size,
                CFrame = CFrame.new(center),
                Name = "VirtualSafeZone"
            }
            zones[#zones+1] = virtualZone
        end
        cachedSafeZones = zones
        return zones
    end

    local function IsInSafeZone(character)
        if not character then return false end
        local plr = Players:GetPlayerFromCharacter(character)
        if plr and plr:GetAttribute("SafeZone") then
            return true
        end
        local zones = CollectSafeZones()
        if #zones == 0 then return false end
        for _,partName in ipairs(SAFE_ZONE_PARTS) do
            local part = character:FindFirstChild(partName)
            if part and part:IsA("BasePart") then
                for _,zone in ipairs(zones) do
                    if IsPartIntersectingZone(part,zone) then
                        return true
                    end
                end
            end
        end
        return false
    end

    local function IsPlayerTargeted(player,useList,targets)
        if not useList then return true end
        return targets[player.Name] == true
    end

    local function FastCanSee(fromPos, targetPart, ignoreList, depth)
        depth = depth or 0
        if depth > 10 then return false, nil end
        local targetPos = targetPart.Position
        local params = RaycastParams.new()
        params.FilterDescendantsInstances = ignoreList
        params.FilterType = Enum.RaycastFilterType.Exclude
        params.IgnoreWater = true
        local result = Workspace:Raycast(fromPos, targetPos - fromPos, params)
        if not result then
            return true, targetPart.Parent
        end
        local hitPart = result.Instance
        local parent = hitPart.Parent
        if parent then
            local hum = parent:FindFirstChild("Humanoid")
            if hum and parent == targetPart.Parent then
                return true, parent
            end
            if parent:IsA("Accessory") or parent:IsA("Hat") then
                local owner = parent.Parent
                if owner and owner:FindFirstChild("Humanoid") and owner == targetPart.Parent then
                    return true, owner
                end
                ignoreList[#ignoreList + 1] = parent
                return FastCanSee(fromPos, targetPart, ignoreList, depth + 1)
            end
        end
        if hitPart.Transparency >= 0.9 or not hitPart.CanCollide then
            ignoreList[#ignoreList + 1] = hitPart
            return FastCanSee(fromPos, targetPart, ignoreList, depth + 1)
        end
        return false, nil
    end

    local Cache = {
        lastFireTime = 0,
        lastAimlockFireTime = 0,
        minFireInterval = 0.01
    }

    local function GetClosestEnemyHead(forAutoFire)
        if not (currentChar and currentHRP) then
            return nil, nil
        end
        if forAutoFire and currentChar:FindFirstChildOfClass("ForceField") then
            return nil, nil
        end
        local mousePos = UserInputService:GetMouseLocation()
        local bestDist = math.huge
        local bestHead, bestPlayer = nil, nil
        local myPos = currentHRP.Position
        local players = Players:GetPlayers()
        for i = 1,#players do
            local plr = players[i]
            if plr ~= LocalPlayer then
                local character = plr.Character
                if character then
                    local head = character:FindFirstChild("Head")
                    local humanoid = character:FindFirstChild("Humanoid")
                    local enemyHRP = character:FindFirstChild("HumanoidRootPart")
                    if head and humanoid and enemyHRP and humanoid.Health > 0 then
                        if IsPlayerTargeted(plr, SilentAim.UseTargetList, SilentAim.TargetedPlayers) then
                            if not IsInSafeZone(character) then
                                if not character:FindFirstChildOfClass("ForceField") then
                                    local dist3D = (head.Position - myPos).Magnitude
                                    if dist3D <= SilentAim.MaxDistance then
                                        local head2D = Camera:WorldToViewportPoint(head.Position)
                                        if head2D.Z > 0 then
                                            local screenDist = (Vector2.new(head2D.X,head2D.Y) - mousePos).Magnitude
                                            if screenDist < bestDist then
                                                local canHit, hitChar = FastCanSee(myPos, head, {currentChar, Camera})
                                                if canHit and hitChar == character then
                                                    bestDist = screenDist
                                                    bestHead = head
                                                    bestPlayer = plr
                                                end
                                            end
                                        end
                                    end
                                end
                            end
                        end
                    end
                end
            end
        end
        return bestHead, bestPlayer
    end

    local function DrawSafeZoneVisual()
        if SafeZoneESP then
            SafeZoneESP:Destroy()
            SafeZoneESP = nil
        end
        local zones = CollectSafeZones()
        if #zones > 0 then
            SafeZoneESP = Instance.new("Folder")
            SafeZoneESP.Name = "SafeZoneESP"
            SafeZoneESP.Parent = game.CoreGui
            for _,zone in ipairs(zones) do
                if type(zone) == "table" then
                    local part = Instance.new("Part")
                    part.Size = zone.Size
                    part.CFrame = zone.CFrame
                    part.Anchored = true
                    part.CanCollide = false
                    part.Transparency = 1
                    part.Name = "VirtualSafeZonePart"
                    part.Parent = SafeZoneESP
                    local box = Instance.new("SelectionBox")
                    box.Adornee = part
                    box.Color3 = Color3.fromRGB(0,100,255)
                    box.LineThickness = 0.03
                    box.Transparency = 0
                    box.SurfaceTransparency = 1
                    box.Parent = SafeZoneESP
                else
                    local box = Instance.new("SelectionBox")
                    box.Adornee = zone
                    box.Color3 = Color3.fromRGB(0,100,255)
                    box.LineThickness = 0.03
                    box.Transparency = 0
                    box.SurfaceTransparency = 1
                    box.Parent = SafeZoneESP
                end
            end
        end
    end

    SilentAimCore.IsInSafeZone = IsInSafeZone
    SilentAimCore.IsPlayerTargeted = IsPlayerTargeted
    SilentAimCore.CollectSafeZones = CollectSafeZones
    SilentAimCore.DrawSafeZoneVisual = DrawSafeZoneVisual
    SilentAimCore.GetClosestEnemyHead = GetClosestEnemyHead
    SilentAimCore.FastCanSee = FastCanSee
    SilentAimCore.Cache = Cache
    SilentAimCore.IsPointInPart = IsPointInPart
    SilentAimCore.IsPartIntersectingZone = IsPartIntersectingZone
    SilentAimCore.DoBoxesIntersect = DoBoxesIntersect
end

local function IsCharacterFullyInsideSafeZone_R6(character)
    if not character then return false end
    if not SilentAimCore or not SilentAimCore.CollectSafeZones or not SilentAimCore.IsPartIntersectingZone then
        return false
    end
    local zones = SilentAimCore.CollectSafeZones()
    if #zones == 0 then return false end
    local R6_PARTS = {
        "HumanoidRootPart",
        "Head",
        "Torso",
        "Left Arm",
        "Right Arm",
        "Left Leg",
        "Right Leg"
    }
    for _,partName in ipairs(R6_PARTS) do
        local part = character:FindFirstChild(partName)
        if part and part:IsA("BasePart") then
            for _,zone in ipairs(zones) do
                if SilentAimCore.IsPartIntersectingZone(part,zone) then
                    return true
                end
            end
        end
    end
    return false
end

local function IsPlayerSafeZoneProtected(player)
    if not player or not player.Character then return false end
    local char = player.Character
    if player:GetAttribute("SafeZone") then
        return true
    end
    if char:FindFirstChildOfClass("ForceField") then
        return true
    end
    local fullyInside = IsCharacterFullyInsideSafeZone_R6(char)
    if not fullyInside then
        return false
    end
    local team = player.Team
    if team and ProtectedTeams[team.Name] then
        return true
    end
    return false
end

local function IsLocalPlayerProtected()
    return IsPlayerSafeZoneProtected(LocalPlayer)
end

local function IsPlayerProtectedBySafeZone(player)
    return IsPlayerSafeZoneProtected(player)
end

local function HasForceFieldFromChar(char)
    return char and char:FindFirstChildOfClass("ForceField") ~= nil
end

local function CanAutoFireAtPlayer(targetPlayer)
    if not (targetPlayer and targetPlayer.Character) then
        return false
    end
    local char = targetPlayer.Character
    local hum = char:FindFirstChild("Humanoid")
    if not hum or hum.Health <= 0 then
        return false
    end
    if IsPlayerSafeZoneProtected(LocalPlayer) then
        return false
    end
    if IsPlayerSafeZoneProtected(targetPlayer) then
        return false
    end
    return true
end

local oldIndex
oldIndex = hookmetamethod(game,"__index",function(self,key)
    if SilentAim.Enabled and self:IsA("Mouse") and key == "Hit" then
        local head,plr = SilentAimCore.GetClosestEnemyHead(false)
        if head and plr then
            if not IsPlayerSafeZoneProtected(LocalPlayer) and not IsPlayerSafeZoneProtected(plr) then
                local pos = head.Position
                if SilentAim.UsePrediction and SilentAim.PredictionAmount > 0 then
                    local enemyHRP = plr.Character and plr.Character:FindFirstChild("HumanoidRootPart")
                    if enemyHRP then
                        pos = pos + enemyHRP.AssemblyLinearVelocity * SilentAim.PredictionAmount
                    end
                end
                return CFrame.new(pos)
            end
        end
    end
    return oldIndex(self,key)
end)

local bodyPartMapping = {
    ["Head"] = {parts={"Head"},offset=Vector3.new(0,0.3,0)},
    ["Torso"] = {parts={"Torso","UpperTorso"},offset=Vector3.new(0,0.2,0)},
    ["Left Arm"] = {parts={"Left Arm","LeftUpperArm"},offset=Vector3.new(0,0.15,0)},
    ["Right Arm"] = {parts={"Right Arm","RightUpperArm"},offset=Vector3.new(0,0.15,0)},
    ["Left Leg"] = {parts={"Left Leg","LeftUpperLeg"},offset=Vector3.new(0,0.1,0)},
    ["Right Leg"] = {parts={"Right Leg","RightUpperLeg"},offset=Vector3.new(0,0.1,0)}
}

local function GetBodyPart(character,partName)
    local mapping = bodyPartMapping[partName]
    if mapping then
        local parts = mapping.parts
        for i = 1,#parts do
            local p = character:FindFirstChild(parts[i])
            if p then
                return p,mapping.offset
            end
        end
    end
    return character:FindFirstChild(partName),Vector3.new(0,0,0)
end

local CurrentGun = nil
local CurrentGunConfig = nil

local function UpdateCurrentGun()
    CurrentGun = nil
    CurrentGunConfig = nil
    local char = LocalPlayer.Character
    if not char then return end
    for _, child in ipairs(char:GetChildren()) do
        if child:IsA("Tool") and child:FindFirstChild("ConfigGun") then
            CurrentGun = child
            local cfgModule = child:FindFirstChild("ConfigGun")
            if cfgModule then
                local ok, cfg = pcall(require, cfgModule)
                if ok and type(cfg) == "table" then
                    CurrentGunConfig = cfg
                end
            end
            break
        end
    end
end

local function HookCharacter(char)
    char.ChildAdded:Connect(function(child)
        if child:IsA("Tool") then
            task.defer(UpdateCurrentGun)
        end
    end)
    char.ChildRemoved:Connect(function(child)
        if child:IsA("Tool") then
            task.defer(UpdateCurrentGun)
        end
    end)
    task.defer(UpdateCurrentGun)
end

if LocalPlayer.Character then
    HookCharacter(LocalPlayer.Character)
end

local function DirectFireSilentAim()
    if not SilentAim.Enabled then return end
    if not SilentAim.AutoFireEnabled then return end
    if SilentAim.AutoFireMode ~= "DirectRemote" then return end
    if not fireEvent then return end
    if not (currentChar and currentHRP and currentHead) then return end
    if not CurrentGun or not CurrentGunConfig then return end
    local now = tick()
    if now - SilentAimCore.Cache.lastFireTime < SilentAimCore.Cache.minFireInterval then return end
    if IsPlayerSafeZoneProtected(LocalPlayer) then return end
    local cfg = CurrentGunConfig
    if cfg.SafeMode or (cfg.AmmoInMag or 0) <= 0 then return end
    local head, plr = SilentAimCore.GetClosestEnemyHead(true)
    if not head or not plr then return end
    if not CanAutoFireAtPlayer(plr) then return end
    local targetPos = head.Position
    if SilentAim.UsePrediction and SilentAim.PredictionAmount > 0 then
        local enemyHRP = plr.Character and plr.Character:FindFirstChild("HumanoidRootPart")
        if enemyHRP then
            targetPos = targetPos + enemyHRP.AssemblyLinearVelocity * SilentAim.PredictionAmount
        end
    end
    local canHit, hitChar = SilentAimCore.FastCanSee(currentHead.Position, head, {currentChar, Camera})
    if not (canHit and hitChar == plr.Character) then return end
    SilentAimCore.Cache.lastFireTime = now
    fireEvent:FireServer(targetPos, targetPos, head)
end

local function DirectFireAimlock()
    if not AimLock.Enabled then return end
    if not AimLock.AutoFireEnabled then return end
    if AimLock.AutoFireMode ~= "DirectRemote" then return end
    if not fireEvent then return end
    if not (currentChar and currentHead) then return end
    if not CurrentGun or not CurrentGunConfig then return end
    if not AimLock.Target then return end
    local targetPlayer = AimLock.Target
    local character = targetPlayer.Character
    if not character then return end
    local now = tick()
    if now - SilentAimCore.Cache.lastAimlockFireTime < SilentAimCore.Cache.minFireInterval then return end
    local cfg = CurrentGunConfig
    if cfg.SafeMode or (cfg.AmmoInMag or 0) <= 0 then return end
    if not CanAutoFireAtPlayer(targetPlayer) then return end
    local humanoid = character:FindFirstChild("Humanoid")
    if not humanoid or humanoid.Health <= 0 then return end
    local part, offset = GetBodyPart(character, AimLock.AimPart)
    if not part then return end
    local targetPos = part.Position + offset
    if AimLock.UsePrediction and AimLock.PredictionAmount > 0 then
        local enemyHRP = character:FindFirstChild("HumanoidRootPart")
        if enemyHRP then
            targetPos = targetPos + enemyHRP.AssemblyLinearVelocity * AimLock.PredictionAmount
        end
    end
    local canHit, hitChar = SilentAimCore.FastCanSee(currentHead.Position, part, {currentChar, Camera})
    if not (canHit and hitChar == character) then return end
    SilentAimCore.Cache.lastAimlockFireTime = now
    fireEvent:FireServer(targetPos, targetPos, part)
end

local function SilentAimAutoFire()
    if not SilentAim.Enabled then return end
    if not SilentAim.AutoFireEnabled then return end
    if SilentAim.AutoFireMode == "DirectRemote" then
        DirectFireSilentAim()
        return
    end
    if not CurrentGun or not CurrentGunConfig then return end
    if not (currentChar and currentHRP) then return end
    local now = tick()
    if now - SilentAimCore.Cache.lastFireTime < SilentAimCore.Cache.minFireInterval then return end
    if IsPlayerSafeZoneProtected(LocalPlayer) then return end
    local cfg = CurrentGunConfig
    if cfg.SafeMode or (cfg.AmmoInMag or 0) <= 0 then return end
    local head, plr = SilentAimCore.GetClosestEnemyHead(true)
    if not head or not plr then return end
    if not CanAutoFireAtPlayer(plr) then return end
    SilentAimCore.Cache.lastFireTime = now
    FastClick()
end

local function AimlockAutoFire()
    if not AimLock.Enabled then return end
    if not AimLock.AutoFireEnabled then return end
    if AimLock.AutoFireMode == "DirectRemote" then
        DirectFireAimlock()
        return
    end
    if not CurrentGun or not CurrentGunConfig then return end
    if not (currentChar and currentHead) then return end
    if not AimLock.Target then return end
    local targetPlayer = AimLock.Target
    local character = targetPlayer.Character
    if not character then return end
    local now = tick()
    if now - SilentAimCore.Cache.lastAimlockFireTime < SilentAimCore.Cache.minFireInterval then return end
    local cfg = CurrentGunConfig
    if cfg.SafeMode or (cfg.AmmoInMag or 0) <= 0 then return end
    if not CanAutoFireAtPlayer(targetPlayer) then return end
    local humanoid = character:FindFirstChild("Humanoid")
    if not humanoid or humanoid.Health <= 0 then return end
    local part, offset = GetBodyPart(character, AimLock.AimPart)
    if not part then return end
    local canHit, hitChar = SilentAimCore.FastCanSee(currentHead.Position, part, {currentChar, Camera})
    if canHit and hitChar == character then
        SilentAimCore.Cache.lastAimlockFireTime = now
        FastClick()
    end
end

RunService.RenderStepped:Connect(function()
    if AimLock.Enabled and AimLock.Target then
        local character = AimLock.Target.Character
        if not character then
            AimLock.Target = nil
            UserInputService.MouseBehavior = Enum.MouseBehavior.Default
            return
        end
        local humanoid = character:FindFirstChild("Humanoid")
        if not humanoid or humanoid.Health <= 0 then
            AimLock.Target = nil
            UserInputService.MouseBehavior = Enum.MouseBehavior.Default
            return
        end
        local part,offset = GetBodyPart(character,AimLock.AimPart)
        if part then
            local targetPosition = part.Position + offset
            if AimLock.UsePrediction and AimLock.PredictionAmount > 0 then
                local enemyHRP = character:FindFirstChild("HumanoidRootPart")
                if enemyHRP then
                    targetPosition = targetPosition + enemyHRP.AssemblyLinearVelocity * AimLock.PredictionAmount
                end
            end
            Camera.CFrame = CFrame.new(Camera.CFrame.Position,targetPosition)
        else
            AimLock.Target = nil
            UserInputService.MouseBehavior = Enum.MouseBehavior.Default
        end
    end
end)

local function IsPlayerValidAndAlive(plr)
    if not plr then return false end
    if plr.Parent ~= Players then return false end
    local char = plr.Character
    if not char or not char.Parent then return false end
    local hum = char:FindFirstChildOfClass("Humanoid")
    if not hum then return false end
    if hum.Health <= 1 then return false end
    local state = hum:GetState()
    if state == Enum.HumanoidStateType.Dead then return false end
    local hrp = char:FindFirstChild("HumanoidRootPart")
    if not hrp then return false end
    return true
end

local function RemoveSafeZoneIndicator(plr)
    local gui = SafeZonePlayerIndicators[plr]
    if gui then
        gui:Destroy()
        SafeZonePlayerIndicators[plr] = nil
    end
    local conns = SafeZonePlayerConnections[plr]
    if conns then
        for _,c in pairs(conns) do
            if c then c:Disconnect() end
        end
        SafeZonePlayerConnections[plr] = nil
    end
end

local function CreateSafeZoneIndicator(plr)
    if not IsPlayerValidAndAlive(plr) then return nil end
    local char = plr.Character
    local torso = char:FindFirstChild("Torso") or char:FindFirstChild("HumanoidRootPart")
    if not torso then return nil end
    local indicator = Instance.new("BillboardGui")
    indicator.Name = "SafeZoneIndicator_"..plr.UserId
    indicator.Size = UDim2.new(0, 14, 0, 14)
    indicator.AlwaysOnTop = true
    indicator.Adornee = torso
    indicator.Parent = game.CoreGui
    local dot = Instance.new("Frame", indicator)
    dot.Size = UDim2.new(1, 0, 1, 0)
    dot.BackgroundColor3 = Color3.fromRGB(0, 255, 0)
    dot.BorderSizePixel = 0
    dot.AnchorPoint = Vector2.new(0.5, 0.5)
    dot.Position = UDim2.new(0.5, 0, 0.5, 0)
    local corner = Instance.new("UICorner", dot)
    corner.CornerRadius = UDim.new(1, 0)
    SafeZonePlayerIndicators[plr] = indicator
    if not SafeZonePlayerConnections[plr] then
        SafeZonePlayerConnections[plr] = {}
    end
    local charConnRem = plr.CharacterRemoving:Connect(function()
        RemoveSafeZoneIndicator(plr)
    end)
    local hum = char:FindFirstChildOfClass("Humanoid")
    local humDiedConn
    if hum then
        humDiedConn = hum.Died:Connect(function()
            RemoveSafeZoneIndicator(plr)
        end)
    end
    table.insert(SafeZonePlayerConnections[plr], charConnRem)
    if humDiedConn then
        table.insert(SafeZonePlayerConnections[plr], humDiedConn)
    end
    return indicator
end

local function UpdateSafeZoneIndicators()
    if not ShowSafeZonePlayersEnabled then return end
    for plr, gui in pairs(SafeZonePlayerIndicators) do
        if (not plr.Parent) or (not IsPlayerValidAndAlive(plr)) then
            RemoveSafeZoneIndicator(plr)
        end
    end
    local players = Players:GetPlayers()
    for i = 1,#players do
        local plr = players[i]
        if plr ~= LocalPlayer then
            if IsPlayerValidAndAlive(plr) then
                local char = plr.Character
                local fullyInside = IsCharacterFullyInsideSafeZone_R6(char)
                if fullyInside then
                    if not SafeZonePlayerIndicators[plr] then
                        CreateSafeZoneIndicator(plr)
                    else
                        local torso = char:FindFirstChild("Torso") or char:FindFirstChild("HumanoidRootPart")
                        if torso then
                            SafeZonePlayerIndicators[plr].Adornee = torso
                        end
                    end
                else
                    RemoveSafeZoneIndicator(plr)
                end
            else
                RemoveSafeZoneIndicator(plr)
            end
        end
    end
end

local function StartShowSafeZonePlayers()
    ShowSafeZonePlayersEnabled = true
    task.spawn(function()
        while ShowSafeZonePlayersEnabled do
            pcall(UpdateSafeZoneIndicators)
            task.wait(0.15)
        end
    end)
end

local function StopShowSafeZonePlayers()
    ShowSafeZonePlayersEnabled = false
    for plr,_ in pairs(SafeZonePlayerIndicators) do
        RemoveSafeZoneIndicator(plr)
    end
    SafeZonePlayerIndicators = {}
    SafeZonePlayerConnections = {}
end

local function GetAllPlayers()
    local players = Players:GetPlayers()
    local names = {}
    for i = 1,#players do
        local p = players[i]
        if p ~= LocalPlayer then
            names[#names+1] = p.Name
        end
    end
    return names
end

local function CreatePlayerFrame(player,scrollFrame,targetedTable)
    local frame = Instance.new("Frame")
    frame.Name = player.Name
    frame.Size = UDim2.new(1,-10,0,75)
    frame.BackgroundColor3 = targetedTable[player.Name] and Color3.fromRGB(60,140,60) or Color3.fromRGB(35,35,35)
    frame.BorderSizePixel = 0
    frame.Parent = scrollFrame
    local corner = Instance.new("UICorner")
    corner.CornerRadius = UDim.new(0,10)
    corner.Parent = frame
    local avatar = Instance.new("ImageLabel")
    avatar.Name = "Avatar"
    avatar.Size = UDim2.new(0,65,0,65)
    avatar.Position = UDim2.new(0,5,0,5)
    avatar.BackgroundColor3 = Color3.fromRGB(25,25,25)
    avatar.BorderSizePixel = 0
    avatar.Image = ""
    avatar.Parent = frame
    local avatarCorner = Instance.new("UICorner")
    avatarCorner.CornerRadius = UDim.new(0,10)
    avatarCorner.Parent = avatar
    task.spawn(function()
        local ok,imageId = pcall(function()
            return Players:GetUserThumbnailAsync(player.UserId,Enum.ThumbnailType.HeadShot,Enum.ThumbnailSize.Size150x150)
        end)
        if ok and imageId then
            avatar.Image = imageId
        end
    end)
    local teamColor = player.Team and player.Team.TeamColor.Color or Color3.fromRGB(240,240,240)
    local display = Instance.new("TextLabel")
    display.Name = "DisplayName"
    display.Size = UDim2.new(1,-80,0,28)
    display.Position = UDim2.new(0,75,0,8)
    display.BackgroundTransparency = 1
    display.Text = player.DisplayName
    display.TextColor3 = teamColor
    display.TextSize = 17
    display.Font = Enum.Font.GothamBold
    display.TextXAlignment = Enum.TextXAlignment.Left
    display.TextTruncate = Enum.TextTruncate.AtEnd
    display.Parent = frame
    local user = Instance.new("TextLabel")
    user.Name = "UserName"
    user.Size = UDim2.new(1,-80,0,20)
    user.Position = UDim2.new(0,75,0,36)
    user.BackgroundTransparency = 1
    user.Text = "@"..player.Name
    user.TextColor3 = Color3.fromRGB(160,160,160)
    user.TextSize = 13
    user.Font = Enum.Font.Gotham
    user.TextXAlignment = Enum.TextXAlignment.Left
    user.TextTruncate = Enum.TextTruncate.AtEnd
    user.Parent = frame
    local btn = Instance.new("TextButton")
    btn.Name = "SelectButton"
    btn.Size = UDim2.new(1,0,1,0)
    btn.BackgroundTransparency = 1
    btn.Text = ""
    btn.Parent = frame
    btn.MouseButton1Click:Connect(function()
        if targetedTable[player.Name] then
            targetedTable[player.Name] = nil
            frame.BackgroundColor3 = Color3.fromRGB(35,35,35)
        else
            targetedTable[player.Name] = true
            frame.BackgroundColor3 = Color3.fromRGB(60,140,60)
        end
    end)
    btn.MouseEnter:Connect(function()
        if not targetedTable[player.Name] then
            frame.BackgroundColor3 = Color3.fromRGB(45,45,45)
        end
    end)
    btn.MouseLeave:Connect(function()
        if not targetedTable[player.Name] then
            frame.BackgroundColor3 = Color3.fromRGB(35,35,35)
        end
    end)
    return frame
end

local function UpdatePlayerList(scrollFrame,targetedTable)
    if not scrollFrame then return end
    local children = scrollFrame:GetChildren()
    local map = {}
    for i = 1,#children do
        local f = children[i]
        if f:IsA("Frame") and f.Name ~= "UIListLayout" then
            map[f.Name] = f
        end
    end
    local players = Players:GetPlayers()
    for i = 1,#players do
        local plr = players[i]
        if plr ~= LocalPlayer then
            local frame = map[plr.Name]
            if not frame then
                CreatePlayerFrame(plr,scrollFrame,targetedTable)
            else
                frame.BackgroundColor3 = targetedTable[plr.Name] and Color3.fromRGB(60,140,60) or Color3.fromRGB(35,35,35)
                local teamColor = plr.Team and plr.Team.TeamColor.Color or Color3.fromRGB(240,240,240)
                local disp = frame:FindFirstChild("DisplayName")
                if disp then
                    disp.TextColor3 = teamColor
                    disp.Text = plr.DisplayName
                end
                local user = frame:FindFirstChild("UserName")
                if user then
                    user.Text = "@"..plr.Name
                end
            end
            map[plr.Name] = nil
        end
    end
    for _,f in pairs(map) do
        f:Destroy()
    end
    local layout = scrollFrame:FindFirstChildOfClass("UIListLayout")
    if layout then
        scrollFrame.CanvasSize = UDim2.new(0,0,0,layout.AbsoluteContentSize.Y+10)
    end
end

local function MakeDraggable(frame)
    local dragging = false
    local dragInput
    local mousePos
    local framePos
    frame.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            dragging = true
            mousePos = input.Position
            framePos = frame.Position
            input.Changed:Connect(function()
                if input.UserInputState == Enum.UserInputState.End then
                    dragging = false
                end
            end)
        end
    end)
    frame.InputChanged:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseMovement then
            dragInput = input
        end
    end)
    UserInputService.InputChanged:Connect(function(input)
        if input == dragInput and dragging then
            local delta = input.Position-mousePos
            frame.Position = UDim2.new(framePos.X.Scale,framePos.X.Offset+delta.X,framePos.Y.Scale,framePos.Y.Offset+delta.Y)
        end
    end)
end

local function CreateTargetListGUI(title)
    local gui = Instance.new("ScreenGui")
    gui.Name = "TargetListGUI"
    gui.ResetOnSpawn = false
    gui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    gui.IgnoreGuiInset = true
    gui.Parent = game.CoreGui
    local main = Instance.new("Frame")
    main.Name = "MainFrame"
    main.Size = UDim2.new(0,420,0,520)
    main.Position = UDim2.new(0.5,-210,0.5,-260)
    main.BackgroundColor3 = Color3.fromRGB(25,25,25)
    main.BorderSizePixel = 0
    main.Active = true
    main.Parent = gui
    local corner = Instance.new("UICorner")
    corner.CornerRadius = UDim.new(0,12)
    corner.Parent = main
    local top = Instance.new("Frame")
    top.Name = "TopBar"
    top.Size = UDim2.new(1,0,0,45)
    top.BackgroundColor3 = Color3.fromRGB(34,34,34)
    top.BorderSizePixel = 0
    top.Parent = main
    local topCorner = Instance.new("UICorner")
    topCorner.CornerRadius = UDim.new(0,12)
    topCorner.Parent = top
    local cover = Instance.new("Frame")
    cover.Size = UDim2.new(1,0,0,12)
    cover.Position = UDim2.new(0,0,1,-12)
    cover.BackgroundColor3 = Color3.fromRGB(34,34,34)
    cover.BorderSizePixel = 0
    cover.Parent = top
    local titleLabel = Instance.new("TextLabel")
    titleLabel.Name = "Title"
    titleLabel.Size = UDim2.new(1,-60,1,0)
    titleLabel.Position = UDim2.new(0,18,0,0)
    titleLabel.BackgroundTransparency = 1
    titleLabel.Text = title
    titleLabel.TextColor3 = Color3.fromRGB(240,240,240)
    titleLabel.TextSize = 18
    titleLabel.Font = Enum.Font.GothamBold
    titleLabel.TextXAlignment = Enum.TextXAlignment.Left
    titleLabel.Parent = top
    local close = Instance.new("TextButton")
    close.Name = "CloseButton"
    close.Size = UDim2.new(0,32,0,32)
    close.Position = UDim2.new(1,-38,0,6)
    close.BackgroundTransparency = 1
    close.BorderSizePixel = 0
    close.Text = "X"
    close.TextColor3 = Color3.fromRGB(200,200,200)
    close.TextSize = 16
    close.Font = Enum.Font.GothamBold
    close.Parent = top
    close.MouseEnter:Connect(function()
        close.TextColor3 = Color3.fromRGB(255,255,255)
    end)
    close.MouseLeave:Connect(function()
        close.TextColor3 = Color3.fromRGB(200,200,200)
    end)
    local scroll = Instance.new("ScrollingFrame")
    scroll.Name = "PlayerList"
    scroll.Size = UDim2.new(1,-24,1,-65)
    scroll.Position = UDim2.new(0,12,0,53)
    scroll.BackgroundTransparency = 1
    scroll.BorderSizePixel = 0
    scroll.ScrollBarThickness = 6
    scroll.ScrollBarImageColor3 = Color3.fromRGB(60,60,60)
    scroll.Active = true
    scroll.Parent = main
    local layout = Instance.new("UIListLayout")
    layout.SortOrder = Enum.SortOrder.Name
    layout.Padding = UDim.new(0,6)
    layout.Parent = scroll
    return gui,main,scroll,close
end

local function OpenTargetList(stateTable,title,notifyTitle)
    if stateTable.open then
        if stateTable.gui then
            stateTable.gui:Destroy()
            stateTable.gui = nil
        end
        stateTable.open = false
        Rayfield:Notify({Title = notifyTitle,Content = "Closed",Duration = 1,Image = "list-x"})
    else
        local gui,main,scroll,close = CreateTargetListGUI(title)
        stateTable.gui = gui
        stateTable.open = true
        local players = Players:GetPlayers()
        for i = 1,#players do
            local p = players[i]
            if p ~= LocalPlayer then
                CreatePlayerFrame(p,scroll,stateTable.table)
            end
        end
        local layout = scroll:FindFirstChildOfClass("UIListLayout")
        if layout then
            scroll.CanvasSize = UDim2.new(0,0,0,layout.AbsoluteContentSize.Y+10)
        end
        Rayfield:Notify({Title = notifyTitle,Content = "Opened",Duration = 1,Image = "list-checks"})
        close.MouseButton1Click:Connect(function()
            gui:Destroy()
            stateTable.gui = nil
            stateTable.open = false
            Rayfield:Notify({Title = notifyTitle,Content = "Closed",Duration = 1,Image = "list-x"})
        end)
        MakeDraggable(main)
        local acc = 0
        local hb
        hb = RunService.Heartbeat:Connect(function(dt)
            if gui.Parent == nil then
                if hb then hb:Disconnect() end
                return
            end
            acc = acc + dt
            if acc >= 0.3 then
                acc = 0
                UpdatePlayerList(scroll,stateTable.table)
            end
        end)
        local pAdded = Players.PlayerAdded:Connect(function()
            if gui.Parent then UpdatePlayerList(scroll,stateTable.table) end
        end)
        local pRemoving = Players.PlayerRemoving:Connect(function(plr)
            if stateTable.table[plr.Name] then stateTable.table[plr.Name] = nil end
            if gui.Parent then UpdatePlayerList(scroll,stateTable.table) end
        end)
        gui.Destroying:Connect(function()
            if hb then hb:Disconnect() end
            pAdded:Disconnect()
            pRemoving:Disconnect()
        end)
    end
end

local function StartShowSafeZone()
    ShowSafeZoneEnabled = true
    SilentAimCore.DrawSafeZoneVisual()
end

local function StopShowSafeZone()
    ShowSafeZoneEnabled = false
    if SafeZoneESP then
        SafeZoneESP:Destroy()
        SafeZoneESP = nil
    end
end

local Box = Instance.new("BoxHandleAdornment")
Box.Name = "nilBox"
Box.Size = Vector3.new(1,2,1)
Box.Color3 = Color3.fromRGB(100,100,100)
Box.Transparency = 0.7
Box.ZIndex = 0
Box.AlwaysOnTop = false
Box.Visible = false

local NameTag = Instance.new("BillboardGui")
NameTag.Name = "nilNameTag"
NameTag.Enabled = false
NameTag.Size = UDim2.new(0,200,0,50)
NameTag.AlwaysOnTop = true
NameTag.StudsOffset = Vector3.new(0,1.8,0)
local Tag = Instance.new("TextLabel",NameTag)
Tag.Name = "Tag"
Tag.BackgroundTransparency = 1
Tag.Position = UDim2.new(0,-50,0,0)
Tag.Size = UDim2.new(0,300,0,20)
Tag.TextSize = 15
Tag.TextColor3 = Color3.fromRGB(100,100,100)
Tag.TextStrokeColor3 = Color3.fromRGB(0,0,0)
Tag.TextStrokeTransparency = 0.4
Tag.Text = "nil"
Tag.Font = Enum.Font.SourceSansBold
Tag.TextScaled = false

local function LoadCharacterESP(plr)
    if not PlayerESPEnabled or not Holder then return end
    task.spawn(function()
        repeat task.wait() until plr.Character ~= nil
        if not PlayerESPEnabled then return end
        repeat task.wait() until plr.Character:FindFirstChild("Humanoid")
        if not PlayerESPEnabled then return end
        repeat task.wait() until plr.Character:FindFirstChild("HumanoidRootPart")
        if not PlayerESPEnabled then return end
        repeat task.wait() until plr.Character:FindFirstChild("Head")
        if not PlayerESPEnabled or not Holder then return end
        local folder = Holder:FindFirstChild(plr.Name)
        if not folder then return end
        folder:ClearAllChildren()
        local b = Box:Clone()
        b.Name = plr.Name.."Box"
        b.Adornee = plr.Character
        b.Parent = folder
        local t = NameTag:Clone()
        t.Name = plr.Name.."NameTag"
        t.Enabled = true
        t.Parent = folder
        t.Adornee = plr.Character.Head
        t.Tag.Text = plr.Name
        local c = plr.TeamColor.Color
        b.Color3 = c
        t.Tag.TextColor3 = c
        EspTargets[plr] = {box = b, tag = t}
    end)
end

local function UnloadCharacterESP(plr)
    local data = EspTargets[plr]
    if data then
        if data.box then data.box:Destroy() end
        if data.tag then data.tag:Destroy() end
        EspTargets[plr] = nil
    end
    if Holder then
        local folder = Holder:FindFirstChild(plr.Name)
        if folder then folder:ClearAllChildren() end
    end
    if plr.Character and plr.Character:FindFirstChild("GetReal") then
        plr.Character.GetReal:Destroy()
    end
end

local function LoadPlayerESP(plr)
    if not PlayerESPEnabled or plr == LocalPlayer or not Holder then return end
    local folder = Instance.new("Folder",Holder)
    folder.Name = plr.Name
    playerConnections[plr.Name] = playerConnections[plr.Name] or {}
    playerConnections[plr.Name].CharacterAdded = plr.CharacterAdded:Connect(function()
        if PlayerESPEnabled then pcall(LoadCharacterESP,plr) end
    end)
    playerConnections[plr.Name].CharacterRemoving = plr.CharacterRemoving:Connect(function()
        pcall(UnloadCharacterESP,plr)
    end)
    playerConnections[plr.Name].Changed = plr.Changed:Connect(function(prop)
        if prop == "TeamColor" and PlayerESPEnabled then
            UnloadCharacterESP(plr)
            task.wait()
            LoadCharacterESP(plr)
        end
    end)
    pcall(LoadCharacterESP,plr)
end

local function UnloadPlayerESP(plr)
    UnloadCharacterESP(plr)
    local conns = playerConnections[plr.Name]
    if conns then
        for _,conn in pairs(conns) do conn:Disconnect() end
        playerConnections[plr.Name] = nil
    end
    if Holder then
        local folder = Holder:FindFirstChild(plr.Name)
        if folder then folder:Destroy() end
    end
end

local function StartPlayerESP()
    PlayerESPEnabled = true
    Holder = Instance.new("Folder",game.CoreGui)
    Holder.Name = "ESP"
    local players = Players:GetPlayers()
    for i = 1,#players do
        task.spawn(function() pcall(LoadPlayerESP,players[i]) end)
    end
    playerConnections.PlayerAdded = Players.PlayerAdded:Connect(function(plr)
        if PlayerESPEnabled then pcall(LoadPlayerESP,plr) end
    end)
    playerConnections.PlayerRemoving = Players.PlayerRemoving:Connect(function(plr)
        pcall(UnloadPlayerESP,plr)
    end)
    LocalPlayer.NameDisplayDistance = 0
    espLoopRunning = true
    task.spawn(function()
        while espLoopRunning do
            if not PlayerESPEnabled then break end
            local charLocal = LocalPlayer.Character
            local hrpLocal = charLocal and charLocal:FindFirstChild("HumanoidRootPart")
            for plr,data in pairs(EspTargets) do
                if plr.Character and plr.Character:FindFirstChild("Humanoid") and plr.Character:FindFirstChild("HumanoidRootPart") then
                    plr.Character.Humanoid.DisplayDistanceType = Enum.HumanoidDisplayDistanceType.None
                    local hp = math.floor(plr.Character.Humanoid.Health)
                    if hrpLocal then
                        local distance = math.floor((hrpLocal.Position - plr.Character.HumanoidRootPart.Position).Magnitude)
                        data.tag.Tag.Text = plr.Name.." | "..hp.." HP | "..distance.." Studs"
                    else
                        data.tag.Tag.Text = plr.Name.." | "..hp.." HP"
                    end
                end
            end
            task.wait(0.1)
        end
    end)
    task.spawn(function()
        local function esp(plr,color)
            if not PlayerESPEnabled then return end
            if plr.Character then
                if not plr.Character:FindFirstChild("GetReal") then
                    local h = Instance.new("Highlight")
                    h.RobloxLocked = true
                    h.Name = "GetReal"
                    h.Adornee = plr.Character
                    h.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
                    h.FillColor = color
                    h.Parent = plr.Character
                else
                    plr.Character.GetReal.FillColor = color
                end
            end
        end
        while espLoopRunning do
            if not PlayerESPEnabled then break end
            local pls = Players:GetPlayers()
            for i = 1,#pls do
                local plr = pls[i]
                if plr ~= LocalPlayer and PlayerESPEnabled then
                    pcall(esp,plr,plr.TeamColor.Color)
                end
            end
            task.wait(0.1)
        end
    end)
end

local function StopPlayerESP()
    PlayerESPEnabled = false
    espLoopRunning = false
    for name,conns in pairs(playerConnections) do
        if type(conns) == "table" then
            for _,conn in pairs(conns) do if conn then conn:Disconnect() end end
        elseif typeof(conns) == "RBXScriptConnection" then
            conns:Disconnect()
        end
    end
    playerConnections = {}
    for plr,data in pairs(EspTargets) do
        if data.box then data.box:Destroy() end
        if data.tag then data.tag:Destroy() end
    end
    EspTargets = {}
    local players = Players:GetPlayers()
    for i = 1,#players do
        local plr = players[i]
        if plr.Character and plr.Character:FindFirstChild("GetReal") then
            plr.Character.GetReal:Destroy()
        end
    end
    if Holder then Holder:Destroy() Holder = nil end
end

local function IsGun(tool)
    if not tool or not tool:IsA("Tool") then return false end
    return tool:FindFirstChild("ConfigGun") ~= nil
end

local function IsInPlayerCharacter(tool)
    if not (tool and tool:IsA("Tool")) then return true end
    local parent = tool.Parent
    if not parent then return false end
    if parent:IsA("Model") then
        if Players:GetPlayerFromCharacter(parent) then return true end
    end
    if parent:IsA("Backpack") then
        local plr = parent.Parent
        if plr and plr:IsA("Player") then return true end
    end
    local current = parent
    while current do
        if current == Workspace then return false end
        if current:IsA("Model") and Players:GetPlayerFromCharacter(current) then return true end
        current = current.Parent
    end
    return parent ~= Workspace
end

local function CreateGunESP(tool)
    if not GunESPEnabled or not GunHolder or not tool then return end
    if not IsGun(tool) then return end
    if trackedGuns[tool] then return end
    if IsInPlayerCharacter(tool) then return end
    local handle = tool:FindFirstChild("Handle") or tool:FindFirstChildWhichIsA("BasePart")
    if not handle then return end
    local gui = Instance.new("BillboardGui")
    gui.Name = "GunESP"
    gui.AlwaysOnTop = true
    gui.Size = UDim2.new(0,200,0,50)
    gui.StudsOffset = Vector3.new(0,2,0)
    gui.Adornee = handle
    local text = Instance.new("TextLabel",gui)
    text.BackgroundTransparency = 1
    text.Size = UDim2.new(1,0,1,0)
    text.TextSize = 15
    text.TextColor3 = Color3.fromRGB(0,255,0)
    text.TextStrokeTransparency = 0.4
    text.TextStrokeColor3 = Color3.fromRGB(0,0,0)
    text.Font = Enum.Font.SourceSansBold
    text.Text = tool.Name
    gui.Parent = GunHolder
    trackedGuns[tool] = {gui = gui, label = text}
end

local function RemoveGunESP(tool)
    local data = trackedGuns[tool]
    if data then
        if data.gui then data.gui:Destroy() end
        trackedGuns[tool] = nil
    end
end

local function ScanWorkspace()
    if not GunESPEnabled then return end
    local desc = Workspace:GetDescendants()
    for i = 1,#desc do
        local obj = desc[i]
        if obj:IsA("Tool") and IsGun(obj) and not IsInPlayerCharacter(obj) then
            CreateGunESP(obj)
        end
    end
end

local function StartGunESP()
    GunESPEnabled = true
    GunHolder = Instance.new("Folder",game.CoreGui)
    GunHolder.Name = "GunESP"
    ScanWorkspace()
    gunConnections.DescendantAdded = Workspace.DescendantAdded:Connect(function(obj)
        if GunESPEnabled and obj:IsA("Tool") then
            task.delay(0.5, function()
                if obj and obj.Parent and IsGun(obj) and not IsInPlayerCharacter(obj) then
                    CreateGunESP(obj)
                end
            end)
        end
    end)
    gunConnections.DescendantRemoving = Workspace.DescendantRemoving:Connect(function(obj)
        if obj:IsA("Tool") and trackedGuns[obj] then RemoveGunESP(obj) end
    end)
    gunConnections.PlayerCharacterAdded = {}
    local players = Players:GetPlayers()
    for i = 1,#players do
        local plr = players[i]
        gunConnections.PlayerCharacterAdded[plr.Name] = plr.CharacterAdded:Connect(function()
            task.wait(0.5)
            for tool in pairs(trackedGuns) do
                if IsInPlayerCharacter(tool) then RemoveGunESP(tool) end
            end
        end)
    end
    gunConnections.PlayerAdded = Players.PlayerAdded:Connect(function(plr)
        gunConnections.PlayerCharacterAdded[plr.Name] = plr.CharacterAdded:Connect(function()
            task.wait(0.5)
            for tool in pairs(trackedGuns) do
                if IsInPlayerCharacter(tool) then RemoveGunESP(tool) end
            end
        end)
    end)
    task.spawn(function()
        while GunESPEnabled do
            local charLocal = LocalPlayer.Character
            local hrpLocal = charLocal and charLocal:FindFirstChild("HumanoidRootPart")
            if hrpLocal then
                for tool,data in pairs(trackedGuns) do
                    if tool.Parent then
                        local handle = tool:FindFirstChild("Handle") or tool:FindFirstChildWhichIsA("BasePart")
                        if handle and data.label then
                            local distance = math.floor((hrpLocal.Position - handle.Position).Magnitude)
                            data.label.Text = tool.Name.."\n["..distance.." studs]"
                        end
                    else
                        RemoveGunESP(tool)
                    end
                end
            end
            task.wait(0.1)
        end
    end)
end

local function StopGunESP()
    GunESPEnabled = false
    for tool,data in pairs(trackedGuns) do
        if data.gui then data.gui:Destroy() end
    end
    trackedGuns = {}
    for name,conn in pairs(gunConnections) do
        if name == "PlayerCharacterAdded" then
            for _,c in pairs(conn) do if c then c:Disconnect() end end
        elseif conn then
            conn:Disconnect()
        end
    end
    gunConnections = {}
    if GunHolder then GunHolder:Destroy() GunHolder = nil end
end

local function SaveOriginalLighting()
    OriginalLighting.Ambient = Lighting.Ambient
    OriginalLighting.ColorShift_Bottom = Lighting.ColorShift_Bottom
    OriginalLighting.ColorShift_Top = Lighting.ColorShift_Top
end

local function ApplyFullbright()
    Lighting.Ambient = Color3.fromRGB(255,255,255)
    Lighting.ColorShift_Bottom = Color3.fromRGB(255,255,255)
    Lighting.ColorShift_Top = Color3.fromRGB(255,255,255)
end

local function RestoreOriginalLighting()
    Lighting.Ambient = OriginalLighting.Ambient or Color3.fromRGB(0,0,0)
    Lighting.ColorShift_Bottom = OriginalLighting.ColorShift_Bottom or Color3.fromRGB(0,0,0)
    Lighting.ColorShift_Top = OriginalLighting.ColorShift_Top or Color3.fromRGB(0,0,0)
end

local function StartFullbright()
    FullbrightEnabled = true
    SaveOriginalLighting()
    ApplyFullbright()
    lightingConnection = Lighting.LightingChanged:Connect(function()
        if FullbrightEnabled then ApplyFullbright() end
    end)
end

local function StopFullbright()
    FullbrightEnabled = false
    if lightingConnection then lightingConnection:Disconnect() lightingConnection = nil end
    RestoreOriginalLighting()
end

MainTab:CreateSection("Silent Aim")

MainTab:CreateToggle({
    Name = "Silent Aim",
    CurrentValue = false,
    Flag = "SilentAimToggle",
    Callback = function(v)
        SilentAim.Enabled = v
        Rayfield:Notify({Title = "Silent Aim",Content = v and "Enabled" or "Disabled",Duration = 1,Image = v and "crosshair" or "x"})
    end
})

MainTab:CreateSlider({
    Name = "Max Distance",
    Range = {50,1000},
    Increment = 10,
    Suffix = " studs",
    CurrentValue = 1000,
    Flag = "MaxDistanceSlider",
    Callback = function(v) SilentAim.MaxDistance = v end
})

MainTab:CreateToggle({
    Name = "Auto Fire",
    CurrentValue = false,
    Flag = "SilentAimAutoFireToggle",
    Callback = function(v)
        SilentAim.AutoFireEnabled = v
        Rayfield:Notify({Title = "Auto Fire",Content = v and "Enabled" or "Disabled",Duration = 1,Image = v and "zap" or "zap-off"})
    end
})

MainTab:CreateDropdown({
    Name = "Auto Fire Mode",
    Options = {"Input Simulation","Direct Remote"},
    CurrentOption = {
        SilentAim.AutoFireMode == "DirectRemote"
            and "Direct Remote"
            or "Input Simulation"
    },
    MultipleOptions = false,
    Flag = "SilentAimAutoFireMode",
    Callback = function(opts)
        local selected = opts[1]
        if selected == "Input Simulation" then
            SilentAim.AutoFireMode = "InputSimulation"
            Rayfield:Notify({
                Title = "Auto Fire Mode",
                Content = "Mode set to Input Simulation",
                Duration = 1,
                Image = "mouse-pointer-click"
            })
        else
            SilentAim.AutoFireMode = "DirectRemote"
            Rayfield:Notify({
                Title = "Auto Fire Mode",
                Content = "Mode set to Direct Remote",
                Duration = 1,
                Image = "radio"
            })
        end
    end
})

MainTab:CreateToggle({
    Name = "Use Prediction",
    CurrentValue = false,
    Flag = "PredictionToggle",
    Callback = function(v)
        SilentAim.UsePrediction = v
        Rayfield:Notify({Title = "Prediction",Content = v and "Enabled" or "Disabled",Duration = 1,Image = v and "target" or "x"})
    end
})

MainTab:CreateSlider({
    Name = "Prediction",
    Range = {0,1},
    Increment = 0.01,
    Suffix = "",
    CurrentValue = 0,
    Flag = "PredictionSlider",
    Callback = function(v) SilentAim.PredictionAmount = v end
})

MainTab:CreateToggle({
    Name = "Use Target List",
    CurrentValue = false,
    Flag = "SilentAimTargetListToggle",
    Callback = function(v)
        SilentAim.UseTargetList = v
        Rayfield:Notify({Title = "Target List",Content = v and "Enabled - Only targeting selected players" or "Disabled - Targeting all players",Duration = 1,Image = v and "users" or "users-round"})
    end
})

MainTab:CreateButton({
    Name = "Open Silent Aim Target List",
    Callback = function() OpenTargetList(SilentAim.GUIState,"Silent Aim Target List","Silent Aim Target List") end
})

MainTab:CreateSection("Aim Lock")

MainTab:CreateToggle({
    Name = "Aim Lock",
    CurrentValue = false,
    Flag = "AimLockToggle",
    Callback = function(v)
        AimLock.Enabled = v
        if not v then
            AimLock.Target = nil
            UserInputService.MouseBehavior = Enum.MouseBehavior.Default
        end
        Rayfield:Notify({Title = "Aim Lock",Content = v and "Enabled" or "Disabled",Duration = 1,Image = v and "lock" or "unlock"})
    end
})

MainTab:CreateKeybind({
    Name = "Aim Lock Keybind",
    CurrentKeybind = "",
    HoldToInteract = false,
    Flag = "AimLockKeybind",
    Callback = function()
        if not AimLock.Enabled then return end
        if not AimLock.Target then
            local mousePos = Vector2.new(Mouse.X,Mouse.Y)
            local nearest
            local minDist = math.huge
            local cam = Workspace.CurrentCamera
            local players = Players:GetPlayers()
            for i = 1,#players do
                local plr = players[i]
                if plr ~= LocalPlayer and plr.Character then
                    if SilentAimCore.IsPlayerTargeted(plr,AimLock.UseTargetList,AimLock.TargetedPlayers) then
                        local character = plr.Character
                        local hum = character:FindFirstChild("Humanoid")
                        if hum and hum.Health > 0 then
                            local part,offset = GetBodyPart(character,AimLock.AimPart)
                            if part then
                                local pos3D = part.Position + offset
                                local pos2D,onScreen = cam:WorldToViewportPoint(pos3D)
                                if onScreen and pos2D.Z > 0 then
                                    local d = (Vector2.new(pos2D.X,pos2D.Y)-mousePos).Magnitude
                                    if d < minDist then
                                        minDist = d
                                        nearest = plr
                                    end
                                end
                            end
                        end
                    end
                end
            end
            if nearest then
                AimLock.Target = nearest
                UserInputService.MouseBehavior = Enum.MouseBehavior.LockCenter
            end
        else
            AimLock.Target = nil
            UserInputService.MouseBehavior = Enum.MouseBehavior.Default
        end
    end
})

MainTab:CreateDropdown({
    Name = "Aim Part",
    Options = {"Head","Torso","Left Arm","Right Arm","Left Leg","Right Leg"},
    CurrentOption = {"Head"},
    MultipleOptions = false,
    Flag = "AimLockPart",
    Callback = function(opts)
        AimLock.AimPart = opts[1]
        Rayfield:Notify({Title = "Aim Lock",Content = "Aim part set to "..AimLock.AimPart,Duration = 1,Image = "target"})
    end
})

MainTab:CreateToggle({
    Name = "Auto Fire",
    CurrentValue = false,
    Flag = "AimLockAutoFireToggle",
    Callback = function(v)
        AimLock.AutoFireEnabled = v
        Rayfield:Notify({Title = "Aim Lock Auto Fire",Content = v and "Enabled" or "Disabled",Duration = 1,Image = v and "zap" or "zap-off"})
    end
})

MainTab:CreateDropdown({
    Name = "Auto Fire Mode",
    Options = {"Input Simulation","Direct Remote"},
    CurrentOption = {
        AimLock.AutoFireMode == "DirectRemote"
            and "Direct Remote"
            or "Input Simulation"
    },
    MultipleOptions = false,
    Flag = "AimLockAutoFireMode",
    Callback = function(opts)
        local selected = opts[1]
        if selected == "Input Simulation" then
            AimLock.AutoFireMode = "InputSimulation"
            Rayfield:Notify({
                Title = "Aim Lock Auto Fire Mode",
                Content = "Mode set to Input Simulation",
                Duration = 1,
                Image = "mouse-pointer-click"
            })
        else
            AimLock.AutoFireMode = "DirectRemote"
            Rayfield:Notify({
                Title = "Aim Lock Auto Fire Mode",
                Content = "Mode set to Direct Remote",
                Duration = 1,
                Image = "radio"
            })
        end
    end
})

MainTab:CreateToggle({
    Name = "Use Prediction",
    CurrentValue = false,
    Flag = "AimLockPredictionToggle",
    Callback = function(v)
        AimLock.UsePrediction = v
        Rayfield:Notify({Title = "Aim Lock Prediction",Content = v and "Enabled" or "Disabled",Duration = 1,Image = v and "target" or "x"})
    end
})

MainTab:CreateSlider({
    Name = "Prediction",
    Range = {0,1},
    Increment = 0.01,
    Suffix = "",
    CurrentValue = 0,
    Flag = "AimLockPredictionSlider",
    Callback = function(v) AimLock.PredictionAmount = v end
})

MainTab:CreateToggle({
    Name = "Use Target List",
    CurrentValue = false,
    Flag = "AimLockTargetListToggle",
    Callback = function(v)
        AimLock.UseTargetList = v
        Rayfield:Notify({Title = "Aim Lock Target List",Content = v and "Enabled - Only targeting selected players" or "Disabled - Targeting all players",Duration = 1,Image = v and "users" or "users-round"})
    end
})

MainTab:CreateButton({
    Name = "Open Aim Lock Target List",
    Callback = function() OpenTargetList(AimLock.GUIState,"Aim Lock Target List","Aim Lock Target List") end
})

VisualTab:CreateToggle({
    Name = "Player ESP",
    CurrentValue = false,
    Flag = "PlayerESPToggle",
    Callback = function(v)
        if v then StartPlayerESP() Rayfield:Notify({Title = "Player ESP",Content = "On",Duration = 1,Image = "eye"})
        else StopPlayerESP() Rayfield:Notify({Title = "Player ESP",Content = "Off",Duration = 1,Image = "eye-off"}) end
    end
})

VisualTab:CreateToggle({
    Name = "Gun ESP",
    CurrentValue = false,
    Flag = "GunESPToggle",
    Callback = function(v)
        if v then StartGunESP() Rayfield:Notify({Title = "Gun ESP",Content = "On",Duration = 1,Image = "sword"})
        else StopGunESP() Rayfield:Notify({Title = "Gun ESP",Content = "Off",Duration = 1,Image = "x"}) end
    end
})

VisualTab:CreateToggle({
    Name = "Show Safe Zone",
    CurrentValue = false,
    Flag = "ShowSafeZoneToggle",
    Callback = function(v)
        if v then StartShowSafeZone() Rayfield:Notify({Title = "Show Safe Zone",Content = "Enabled",Duration = 1,Image = "shield"})
        else StopShowSafeZone() Rayfield:Notify({Title = "Show Safe Zone",Content = "Disabled",Duration = 1,Image = "shield-off"}) end
    end
})

VisualTab:CreateToggle({
    Name = "Safe Zone Player Indicators",
    CurrentValue = false,
    Flag = "SafeZonePlayersToggle",
    Callback = function(v)
        if v then StartShowSafeZonePlayers() Rayfield:Notify({Title = "Safe Zone Indicators",Content = "Showing players in safe zones",Duration = 1,Image = "shield-check"})
        else StopShowSafeZonePlayers() Rayfield:Notify({Title = "Safe Zone Indicators",Content = "Disabled",Duration = 1,Image = "shield-off"}) end
    end
})

VisualTab:CreateToggle({
    Name = "Fullbright",
    CurrentValue = false,
    Flag = "FullbrightToggle",
    Callback = function(v)
        if v then StartFullbright() Rayfield:Notify({Title = "Fullbright",Content = "On",Duration = 1,Image = "lightbulb"})
        else StopFullbright() Rayfield:Notify({Title = "Fullbright",Content = "Off",Duration = 1,Image = "lightbulb-off"}) end
    end
})

TeleportTab:CreateSection("TP to the sky")

local function performTeleport()
    if not TeleportEnabled or isActionActive then return end
    isActionActive = true
    local char = LocalPlayer.Character
    if not char then isActionActive = false return end
    local hrp = char:FindFirstChild("HumanoidRootPart")
    local hum = char:FindFirstChild("Humanoid")
    if hrp and hum then
        if originalPosition then
            local currentHeight = hrp.Position.Y
            local originalHeight = originalPosition.Position.Y
            if currentHeight >= originalHeight + HEIGHT_THRESHOLD then
                hrp.CFrame = originalPosition
                originalPosition = nil
            else
                originalPosition = hrp.CFrame
                local pos = hrp.Position
                hrp.CFrame = CFrame.new(pos + Vector3.new(30,500,30))
                hrp.Velocity = hrp.Velocity + Vector3.new(0,30,0)
            end
        else
            originalPosition = hrp.CFrame
            local pos = hrp.Position
            hrp.CFrame = CFrame.new(pos + Vector3.new(30,500,30))
            hrp.Velocity = hrp.Velocity + Vector3.new(0,30,0)
        end
    end
    task.wait(0.5)
    isActionActive = false
end

TeleportTab:CreateToggle({
    Name = "TP 500 studs up",
    CurrentValue = false,
    Flag = "TeleportToggle",
    Callback = function(v)
        TeleportEnabled = v
        if not v then originalPosition = nil end
        Rayfield:Notify({Title = "Teleport 500 studs up",Content = v and "Enabled" or "Disabled",Duration = 1,Image = v and "plane-takeoff" or "plane-landing"})
    end
})

TeleportTab:CreateKeybind({
    Name = "TP 500 studs up Keybind",
    CurrentKeybind = "",
    HoldToInteract = false,
    Flag = "TeleportKeybind",
    Callback = function() performTeleport() end
})

TeleportTab:CreateSection("TP to players")

local function PositionIsFree(cframe,exclude)
    local params = OverlapParams.new()
    params.FilterType = Enum.RaycastFilterType.Exclude
    params.FilterDescendantsInstances = exclude or {}
    local size = Vector3.new(2,4,2)
    return #Workspace:GetPartBoundsInBox(cframe,size,params) == 0
end

local function GroundBelow(pos,exclude)
    local params = RaycastParams.new()
    params.FilterType = Enum.RaycastFilterType.Exclude
    params.FilterDescendantsInstances = exclude or {}
    return Workspace:Raycast(pos+Vector3.new(0,3,0),Vector3.new(0,-12,0),params)
end

local function HasLineOfSight(fromPos,toPos,exclude)
    local params = RaycastParams.new()
    params.FilterType = Enum.RaycastFilterType.Exclude
    params.FilterDescendantsInstances = exclude or {}
    return Workspace:Raycast(fromPos,toPos-fromPos,params) == nil
end

local function BestTeleportCFrameAround(targetHRP,myChar)
    local offset = 3
    local baseCF = targetHRP.CFrame
    local exclude = {myChar,targetHRP.Parent,Camera}
    local behindCF = baseCF * CFrame.new(0,0,offset)
    local behindPos = behindCF.Position
    if PositionIsFree(CFrame.new(behindPos),exclude) then
        local down = GroundBelow(behindPos,exclude)
        if down and down.Instance and down.Instance.CanCollide then
            local finalPos = down.Position + Vector3.new(0,3,0)
            if HasLineOfSight(finalPos + Vector3.new(0,1.5,0),targetHRP.Position,exclude) then
                return CFrame.new(finalPos)
            end
        end
    end
    local candidates = {baseCF * CFrame.new(0,0,-offset),baseCF * CFrame.new(-offset,0,0),baseCF * CFrame.new(offset,0,0)}
    local bestCF
    local bestScore = math.huge
    for i = 1,#candidates do
        local cf = candidates[i]
        local pos = cf.Position
        if PositionIsFree(CFrame.new(pos),exclude) then
            local down = GroundBelow(pos,exclude)
            if down and down.Instance and down.Instance.CanCollide then
                local finalPos = down.Position + Vector3.new(0,3,0)
                if HasLineOfSight(finalPos + Vector3.new(0,1.5,0),targetHRP.Position,exclude) then
                    local dist = (finalPos-targetHRP.Position).Magnitude
                    if dist < bestScore then bestScore = dist bestCF = CFrame.new(finalPos) end
                end
            end
        end
    end
    if bestCF then return bestCF end
    local roughDown = GroundBelow(behindPos,exclude)
    if roughDown and roughDown.Instance and roughDown.Instance.CanCollide then
        return CFrame.new(roughDown.Position + Vector3.new(0,3,0))
    end
    return targetHRP.CFrame + Vector3.new(0,3,0)
end

local function TeleportBehindOrBestSpot()
    if not TeleportToPlayerEnabled then return end
    local myChar = LocalPlayer.Character
    if not myChar then return end
    local myHRP = myChar:FindFirstChild("HumanoidRootPart")
    if not myHRP then return end
    local targetPlayer,targetHRP
    if TPToAimlockedEnabled and AimLock.Target and AimLock.Target.Character then
        targetPlayer = AimLock.Target
        targetHRP = targetPlayer.Character:FindFirstChild("HumanoidRootPart")
        if not targetHRP then return end
    else
        if not SelectedPlayerForTeleport then return end
        targetPlayer = Players:FindFirstChild(SelectedPlayerForTeleport)
        if not targetPlayer or not targetPlayer.Character then return end
        targetHRP = targetPlayer.Character:FindFirstChild("HumanoidRootPart")
        if not targetHRP then return end
    end
    local hum = targetPlayer.Character:FindFirstChild("Humanoid")
    if not hum or hum.Health <= 0 then
        Rayfield:Notify({Title = "Teleport",Content = "Target is dead",Duration = 1,Image = "alert-triangle"})
        return
    end
    if UseMaxTeleportDistance then
        local distance = (targetHRP.Position - myHRP.Position).Magnitude
        if distance > MAX_TELEPORT_DISTANCE then
            Rayfield:Notify({Title = "Teleport",Content = "Target too far ("..math.floor(distance).." studs). Max: 90 studs",Duration = 1,Image = "alert-triangle"})
            return
        end
    end
    local best = BestTeleportCFrameAround(targetHRP,myChar)
    myHRP.CFrame = best or (targetHRP.CFrame + Vector3.new(0,3,0))
end

TeleportTab:CreateToggle({
    Name = "TP To Player",
    CurrentValue = false,
    Flag = "TeleportToPlayerToggle",
    Callback = function(v)
        TeleportToPlayerEnabled = v
        Rayfield:Notify({Title = "Teleport To Player",Content = v and "Enabled" or "Disabled",Duration = 1,Image = v and "users" or "x"})
    end
})

TeleportTab:CreateKeybind({
    Name = "TP To Player Keybind",
    CurrentKeybind = "",
    HoldToInteract = false,
    Flag = "TeleportToPlayerKeybind",
    Callback = function() TeleportBehindOrBestSpot() end
})

TeleportTab:CreateToggle({
    Name = "TP to Aimlocked Player",
    CurrentValue = false,
    Flag = "TPToAimlockedToggle",
    Callback = function(v)
        TPToAimlockedEnabled = v
        Rayfield:Notify({Title = "TP to Aimlocked",Content = v and "Enabled - Keybind will TP to aimlocked player" or "Disabled - Keybind will use dropdown selection",Duration = 1,Image = v and "lock" or "unlock"})
    end
})

TeleportTab:CreateToggle({
    Name = "Use maximum teleport distance (90 studs)",
    CurrentValue = false,
    Flag = "UseMaxDistanceToggle",
    Callback = function(v)
        UseMaxTeleportDistance = v
        Rayfield:Notify({Title = "Max Teleport Distance",Content = v and "Limited to 90 studs" or "No distance limit",Duration = 1,Image = v and "ruler" or "infinity"})
    end
})

local PlayerDropdown = TeleportTab:CreateDropdown({
    Name = "Select Player",
    Options = GetAllPlayers(),
    CurrentOption = {},
    MultipleOptions = false,
    Flag = "PlayerDropdown",
    Callback = function(opts)
        SelectedPlayerForTeleport = opts[1]
        if SelectedPlayerForTeleport then
            Rayfield:Notify({Title = "Teleport",Content = "Selected "..SelectedPlayerForTeleport,Duration = 1,Image = "user"})
        end
    end
})

Players.PlayerAdded:Connect(function()
    task.wait(0.05)
    RebuildPlayerList()
    if PlayerDropdown then PlayerDropdown:Refresh(GetAllPlayers(),true) end
end)

Players.PlayerRemoving:Connect(function()
    task.wait(0.05)
    RebuildPlayerList()
    if PlayerDropdown then PlayerDropdown:Refresh(GetAllPlayers(),true) end
end)

ToolsTab:CreateSection("Player")

ToolsTab:CreateToggle({
    Name = "Auto Sprint",
    CurrentValue = false,
    Flag = "AutoSprintToggle",
    Callback = function(v)
        AutoSprintEnabled = v
        Rayfield:Notify({Title = "Auto Sprint",Content = v and "Enabled" or "Disabled",Duration = 1,Image = v and "footprints" or "x"})
    end
})

ToolsTab:CreateToggle({
    Name = "No Fall Damage",
    CurrentValue = false,
    Flag = "NoFallDamageToggle",
    Callback = function(v)
        NoFallDamageEnabled = v
        Rayfield:Notify({Title = "No Fall Damage",Content = v and "Enabled" or "Disabled",Duration = 1,Image = v and "shield" or "shield-off"})
    end
})

task.spawn(function()
    RunService.Heartbeat:Connect(function()
        if NoFallDamageEnabled then
            local char = LocalPlayer.Character
            if char then
                local hrp = char:FindFirstChild("HumanoidRootPart")
                if hrp then
                    local vel = hrp.Velocity
                    hrp.Velocity = Vector3.new(0,90,0)
                    RunService.RenderStepped:Wait()
                    hrp.Velocity = vel
                end
            end
        end
    end)
end)

ToolsTab:CreateSection("Ladder")

ToolsTab:CreateSlider({
    Name = "Ladder Size",
    Range = {10,1000},
    Increment = 10,
    Suffix = " studs",
    CurrentValue = 500,
    Flag = "LadderSizeSlider",
    Callback = function(v)
        LadderSize = v
    end
})

ToolsTab:CreateButton({
    Name = "Create Ladder",
    Callback = function()
        local char = LocalPlayer.Character
        if not char then
            Rayfield:Notify({
                Title = "Ladder",
                Content = "Character not found",
                Duration = 1,
                Image = "alert-circle"
            })
            return
        end
        local hrp = char:FindFirstChild("HumanoidRootPart")
        if not hrp then
            Rayfield:Notify({
                Title = "Ladder",
                Content = "Character not found",
                Duration = 1,
                Image = "alert-circle"
            })
            return
        end
        local ladderHeight = LadderSize
        local stepHeight = 1
        local stepWidth = 4
        local stepDepth = 0.5
        local sideWidth = 0.3
        local model = Instance.new("Model")
        model.Name = "Ladder"
        local params = RaycastParams.new()
        params.FilterDescendantsInstances = {char}
        params.FilterType = Enum.RaycastFilterType.Exclude
        local res = Workspace:Raycast(hrp.Position, Vector3.new(0,-1000,0), params)
        local groundY = res and res.Position.Y or (hrp.Position.Y-3)
        local ladderPos = hrp.Position + hrp.CFrame.LookVector*5
        ladderPos = Vector3.new(ladderPos.X, groundY, ladderPos.Z)
        local leftPost = Instance.new("Part")
        leftPost.Size = Vector3.new(sideWidth, ladderHeight, sideWidth)
        leftPost.Position = ladderPos + Vector3.new(-stepWidth/2+sideWidth/2, ladderHeight/2, 0)
        leftPost.Anchored = true
        leftPost.Material = Enum.Material.Metal
        leftPost.Color = Color3.fromRGB(100,100,100)
        leftPost.Parent = model
        local rightPost = Instance.new("Part")
        rightPost.Size = Vector3.new(sideWidth, ladderHeight, sideWidth)
        rightPost.Position = ladderPos + Vector3.new(stepWidth/2-sideWidth/2, ladderHeight/2, 0)
        rightPost.Anchored = true
        rightPost.Material = Enum.Material.Metal
        rightPost.Color = Color3.fromRGB(100,100,100)
        rightPost.Parent = model
        local numSteps = math.floor(ladderHeight/stepHeight)
        for i = 1,numSteps do
            local step = Instance.new("Part")
            step.Size = Vector3.new(stepWidth, stepDepth, sideWidth)
            step.Position = ladderPos + Vector3.new(0, i*stepHeight-stepHeight/2, 0)
            step.Anchored = true
            step.Material = Enum.Material.Metal
            step.Color = Color3.fromRGB(120,120,120)
            step.CanCollide = true
            step.Parent = model
        end
        model.Parent = Workspace
        CreatedLadders[#CreatedLadders+1] = model
        Rayfield:Notify({
            Title = "Ladder",
            Content = "Ladder created",
            Duration = 1,
            Image = "check"
        })
    end
})

ToolsTab:CreateButton({
    Name = "Remove All Ladders",
    Callback = function()
        for i = 1,#CreatedLadders do
            local model = CreatedLadders[i]
            if model and model.Parent then
                model:Destroy()
            end
        end
        CreatedLadders = {}
        Rayfield:Notify({
            Title = "Ladder",
            Content = "All ladders removed",
            Duration = 1,
            Image = "trash"
        })
    end
})

ToolsTab:CreateSection("Misc")

local function getEquippedGun()
    local char = LocalPlayer.Character
    if not char then return nil end
    local children = char:GetChildren()
    for i = 1,#children do
        local t = children[i]
        if t:IsA("Tool") and t:FindFirstChild("ConfigGun") then
            return t
        end
    end
    return nil
end

ToolsTab:CreateToggle({
    Name = "No Recoil",
    CurrentValue = false,
    Flag = "NoRecoilToggle",
    Callback = function(v)
        NoRecoilEnabled = v
        Rayfield:Notify({
            Title = "No Recoil",
            Content = v and "Enabled" or "Disabled",
            Duration = 1,
            Image = v and "shield" or "shield-off"
        })
    end
})

ToolsTab:CreateToggle({
    Name = "Auto Reload",
    CurrentValue = false,
    Flag = "AutoReloadToggle",
    Callback = function(v)
        AutoReloadEnabled = v
        Rayfield:Notify({
            Title = "Auto Reload",
            Content = v and "Enabled" or "Disabled",
            Duration = 1,
            Image = v and "rotate-ccw" or "x"
        })
    end
})

ToolsTab:CreateButton({
    Name = "Infinite Yield",
    Callback = function()
        loadstring(game:HttpGet("https://raw.githubusercontent.com/EdgeIY/infiniteyield/master/source"))()
    end
})

local lastAutoFireUpdate = 0

RunService.Heartbeat:Connect(function(dt)
    local now = tick()
    local c = LocalPlayer.Character
    currentChar = c
    if c then
        currentHRP = c:FindFirstChild("HumanoidRootPart")
        currentHead = c:FindFirstChild("Head")
    else
        currentHRP = nil
        currentHead = nil
    end
    if now - lastAutoFireUpdate >= 0.008 then
        lastAutoFireUpdate = now
        SilentAimAutoFire()
        AimlockAutoFire()
    end
    if AutoSprintEnabled and currentChar then
        local hum = currentChar:FindFirstChild("Humanoid")
        if hum and hum.WalkSpeed < 17 then
            hum.WalkSpeed = 17
        end
    end
    if CurrentGun and CurrentGunConfig then
        local cfg = CurrentGunConfig
        local name = CurrentGun.Name
        if NoRecoilEnabled then
            if not OriginalRecoil[name] then
                OriginalRecoil[name] = {RecoilX = cfg.RecoilX, RecoilY = cfg.RecoilY}
            end
            cfg.RecoilX = 0
            cfg.RecoilY = 0
        else
            local o = OriginalRecoil[name]
            if o then
                cfg.RecoilX = o.RecoilX
                cfg.RecoilY = o.RecoilY
            end
        end
        if AutoReloadEnabled then
            local ammo = cfg.AmmoInMag
            if type(ammo) == "number" and ammo <= 0 then
                SafeFireServerReload()
            end
        end
    end
    if TeleportEnabled and originalPosition then
        local char = LocalPlayer.Character
        if char then
            local hrp = char:FindFirstChild("HumanoidRootPart")
            if hrp then
                local currentHeight = hrp.Position.Y
                local originalHeight = originalPosition.Position.Y
                if currentHeight >= originalHeight + HEIGHT_THRESHOLD then
                    local v = hrp.Velocity
                    hrp.Velocity = Vector3.new(v.X,0,v.Z)
                    local av = hrp.AssemblyLinearVelocity
                    hrp.AssemblyLinearVelocity = Vector3.new(av.X,0,av.Z)
                end
            end
        end
    end
end)

LocalPlayer.CharacterAdded:Connect(function(char)
    isActionActive = false
    originalPosition = nil
    HookCharacter(char)
end)

Rayfield:LoadConfiguration()